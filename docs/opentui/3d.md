# 3D Rendering System

OpenTUI provides a full WebGPU-based 3D rendering pipeline that composites Three.js scenes directly into terminal output. The `@opentui/core/3d` subpath export bundles the renderer, canvas, sprite system, texture utilities, animations, and physics adapters.

## Table of Contents

- [Import & Setup](#import--setup)
- [CLICanvas](#clicanvas)
- [ThreeCliRenderer](#threeclirenderer)
- [ThreeRenderable](#threerenderable)
- [TextureUtils](#textureutils)
- [SpriteUtils & SheetSprite](#spriteutils--sheetsprite)
- [SpriteResourceManager](#spriteresourcemanager)
- [SuperSampling](#supersampling)
- [Architecture](#architecture)
- [Related Documentation](#related-documentation)

---

## Import & Setup

The 3D subsystem is available via the `@opentui/core/3d` subpath export. This re-exports Three.js alongside all OpenTUI 3D types:

```typescript
import {
  ThreeRenderable,
  ThreeCliRenderer,
  CLICanvas,
  TextureUtils,
  SpriteUtils,
  SpriteAnimator,
  SpriteResourceManager,
  ExplodingSpriteEffect,
  ExplosionManager,
  PhysicsExplodingSpriteEffect,
  PhysicsExplosionManager,
  SpriteParticleGenerator,
  RapierPhysicsWorld,
  PlanckPhysicsWorld,
} from "@opentui/core/3d"

// Three.js is also re-exported from the same path
import * as THREE from "@opentui/core/3d"
```

### Dependencies

The 3D system depends on several optional peer dependencies (declared in `optionalDependencies`):

| Package | Version | Purpose |
|---------|---------|---------|
| `three` | 0.177.0 | 3D scene graph and rendering |
| `bun-webgpu` | 0.1.5 | WebGPU device access from Bun |
| `@dimforge/rapier2d-simd-compat` | ^0.17.3 | Rapier 2D physics engine |
| `planck` | ^1.4.2 | Planck.js 2D physics engine |

---

## CLICanvas

`CLICanvas` is a GPU-backed offscreen canvas that acts as the bridge between WebGPU rendering and terminal pixel output. It manages a GPU device, readback buffers, and an optional compute-shader super-sampling pipeline.

### Constructor

```typescript
class CLICanvas {
  constructor(
    device: GPUDevice,
    width: number,
    height: number,
    superSample: SuperSampleType,
    sampleAlgo?: SuperSampleAlgorithm
  )
}
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `device` | `GPUDevice` | The WebGPU device to use for rendering |
| `width` | `number` | Canvas width in pixels |
| `height` | `number` | Canvas height in pixels |
| `superSample` | `SuperSampleType` | Super-sampling mode (`"none"`, `"gpu"`, or `"cpu"`) |
| `sampleAlgo` | `SuperSampleAlgorithm` | Optional. Algorithm to use for super-sampling |

### Public Properties

```typescript
superSampleDrawTimeMs: number   // Time spent on super-sample draw pass (ms)
mapAsyncTimeMs: number          // Time spent on GPU buffer map-async (ms)
superSample: SuperSampleType    // Current super-sample mode
```

### Methods

```typescript
// Lifecycle
destroy(): void

// Canvas context (mimics browser canvas API for Three.js compatibility)
getContext(type: string, attrs?: WebGLContextAttributes): GPUCanvasContextMock
setSize(width: number, height: number): void

// Event stubs (for Three.js compatibility)
addEventListener(event: string, listener: any, options?: any): void
removeEventListener(event: string, listener: any, options?: any): void
dispatchEvent(event: Event): void

// Super-sampling
setSuperSample(superSample: SuperSampleType): void
setSuperSampleAlgorithm(superSampleAlgorithm: SuperSampleAlgorithm): void
getSuperSampleAlgorithm(): SuperSampleAlgorithm

// Output
readPixelsIntoBuffer(buffer: OptimizedBuffer): Promise<void>
saveToFile(filePath: string): Promise<void>
```

### Enums

```typescript
enum SuperSampleAlgorithm {
  STANDARD = 0,      // Standard downsampling
  PRE_SQUEEZED = 1   // Pre-squeezed algorithm optimized for terminal aspect ratios
}
```

---

## ThreeCliRenderer

The core renderer that drives Three.js scene rendering through WebGPU and reads pixel data back into an `OptimizedBuffer` for terminal display.

### Constructor

```typescript
class ThreeCliRenderer {
  constructor(cliRenderer: CliRenderer, options: ThreeCliRendererOptions)
}
```

### Options

```typescript
interface ThreeCliRendererOptions {
  width: number              // Render width in pixels
  height: number             // Render height in pixels
  focalLength?: number       // Camera focal length
  backgroundColor?: RGBA     // Background color
  superSample?: SuperSampleType  // Super-sampling mode
  alpha?: boolean            // Enable alpha channel
  autoResize?: boolean       // Auto-resize when terminal resizes
  libPath?: string           // Custom path to native libraries
}
```

### Properties

```typescript
get aspectRatio(): number    // Current width/height aspect ratio
```

### Methods

```typescript
// Lifecycle
init(): Promise<void>
destroy(): void

// Camera
setActiveCamera(camera: PerspectiveCamera | OrthographicCamera): void
getActiveCamera(): PerspectiveCamera | OrthographicCamera

// Rendering
setBackgroundColor(color: RGBA): void
setSize(width: number, height: number, forceUpdate?: boolean): void
drawScene(
  root: Scene,
  buffer: OptimizedBuffer,
  deltaTime: number
): Promise<void>
doDrawScene(
  root: Scene,
  camera: PerspectiveCamera | OrthographicCamera,
  buffer: OptimizedBuffer,
  deltaTime: number
): Promise<void>

// Super-sampling
getSuperSampleAlgorithm(): SuperSampleAlgorithm
setSuperSampleAlgorithm(superSampleAlgorithm: SuperSampleAlgorithm): void
toggleSuperSampling(): void

// Debug & Export
toggleDebugStats(): void
renderStats(buffer: OptimizedBuffer): void
saveToFile(filePath: string): Promise<void>
```

### Enum: SuperSampleType

```typescript
enum SuperSampleType {
  NONE = "none",   // No super-sampling
  GPU = "gpu",     // GPU compute shader super-sampling
  CPU = "cpu"      // CPU-side super-sampling
}
```

---

## ThreeRenderable

`ThreeRenderable` extends `Renderable` to embed a Three.js scene into the OpenTUI render tree. It owns a `ThreeCliRenderer` internally and integrates with the frame callback system for continuous rendering.

### Constructor

```typescript
class ThreeRenderable extends Renderable {
  constructor(ctx: RenderContext, options: ThreeRenderableOptions)
}
```

### Options

```typescript
interface ThreeRenderableOptions extends RenderableOptions<ThreeRenderable> {
  scene?: Scene | null                           // Initial Three.js scene
  camera?: PerspectiveCamera | OrthographicCamera // Initial camera
  renderer?: Omit<ThreeCliRendererOptions, "width" | "height" | "autoResize">
  autoAspect?: boolean                           // Auto-adjust camera aspect on resize
}
```

### Properties & Methods

```typescript
// Properties
get aspectRatio(): number
get renderer(): ThreeCliRenderer

// Scene management
getScene(): Scene | null
setScene(scene: Scene | null): void

// Camera management
getActiveCamera(): PerspectiveCamera | OrthographicCamera
setActiveCamera(camera: PerspectiveCamera | OrthographicCamera): void
setAutoAspect(autoAspect: boolean): void

// Lifecycle (inherited from Renderable, called internally)
protected onResize(width: number, height: number): void
protected renderSelf(buffer: OptimizedBuffer, deltaTime: number): void
protected destroySelf(): void
```

### Usage Example

```typescript
import { createCliRenderer, ThreeRenderable } from "@opentui/core"
import * as THREE from "@opentui/core/3d"

const renderer = await createCliRenderer()

const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(75, 16 / 9, 0.1, 1000)
camera.position.z = 5

const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })
const cube = new THREE.Mesh(geometry, material)
scene.add(cube)

const threeRenderable = new ThreeRenderable(renderer, {
  id: "3d-scene",
  scene,
  camera,
  autoAspect: true,
})

renderer.root.add(threeRenderable)
```

---

## TextureUtils

Static utility class for loading textures from files and generating procedural textures.

### Methods

```typescript
class TextureUtils {
  // Load a texture from a file path using sharp
  // Returns a DataTexture with ImageData on its .image property
  static loadTextureFromFile(path: string): Promise<DataTexture | null>

  // Alias for loadTextureFromFile
  static fromFile(path: string): Promise<DataTexture | null>

  // Generate a checkerboard pattern texture
  static createCheckerboard(
    size?: number,           // Texture dimensions (default varies)
    color1?: Color,          // First check color
    color2?: Color,          // Second check color
    checkSize?: number       // Size of each check square
  ): Texture

  // Generate a gradient texture
  static createGradient(
    size?: number,
    startColor?: Color,
    endColor?: Color,
    direction?: "horizontal" | "vertical" | "radial"
  ): Texture

  // Generate a procedural noise texture
  static createNoise(
    size?: number,
    scale?: number,          // Noise scale factor
    octaves?: number,        // Number of noise octaves
    color1?: Color,
    color2?: Color
  ): Texture
}
```

### Examples

```typescript
import { TextureUtils } from "@opentui/core/3d"
import * as THREE from "@opentui/core/3d"

// Load texture from an image file
const texture = await TextureUtils.fromFile("./assets/brick.png")

// Procedural checkerboard
const checker = TextureUtils.createCheckerboard(
  256,
  new THREE.Color(0xffffff),
  new THREE.Color(0x000000),
  16
)

// Radial gradient
const gradient = TextureUtils.createGradient(
  256,
  new THREE.Color(0xff0000),
  new THREE.Color(0x0000ff),
  "radial"
)

// Multi-octave noise
const noise = TextureUtils.createNoise(256, 1.0, 4)
```

---

## SpriteUtils & SheetSprite

Utilities for loading single sprites and sprite sheets from image files.

### SpriteUtils

```typescript
class SpriteUtils {
  // Load a single sprite from an image file
  static fromFile(
    path: string,
    options?: {
      materialParameters?: Omit<SpriteMaterialParameters, "map">
    }
  ): Promise<Sprite>

  // Load a sprite sheet and return a SheetSprite
  static sheetFromFile(
    path: string,
    numFrames: number
  ): Promise<SheetSprite>
}
```

### SheetSprite

`SheetSprite` extends `THREE.Sprite` with frame-based animation support for horizontal sprite sheets.

```typescript
class SheetSprite extends Sprite {
  constructor(material: SpriteMaterial, numFrames: number)

  // Set the visible frame index (0-based)
  setIndex: (index: number) => void
}
```

### Example

```typescript
import { SpriteUtils } from "@opentui/core/3d"

// Load a single sprite
const sprite = await SpriteUtils.fromFile("./hero.png", {
  materialParameters: { transparent: true },
})
scene.add(sprite)

// Load a sprite sheet with 8 frames
const sheet = await SpriteUtils.sheetFromFile("./walk-cycle.png", 8)
sheet.setIndex(0)  // Show first frame
scene.add(sheet)
```

---

## SpriteResourceManager

A resource management layer for sprite sheets that handles texture caching, instanced mesh pooling, and instance slot allocation. This is the foundation that `SpriteAnimator` builds upon.

### Interfaces

```typescript
interface ResourceConfig {
  imagePath: string        // Path to sprite sheet image
  sheetNumFrames: number   // Total frames in the sheet
}

interface SheetProperties {
  imagePath: string
  sheetTilesetWidth: number   // Number of tile columns
  sheetTilesetHeight: number  // Number of tile rows
  sheetNumFrames: number      // Total frame count
}

interface InstanceManagerOptions {
  maxInstances: number        // Maximum number of instances
  renderOrder?: number        // Render ordering
  depthWrite?: boolean        // Enable depth writes
  name?: string               // Debug name
  frustumCulled?: boolean     // Enable frustum culling
  matrix?: THREE.Matrix4      // Initial transform matrix
}

interface MeshPoolOptions {
  geometry: () => THREE.BufferGeometry
  material: THREE.Material
  maxInstances: number
  name?: string
}
```

### MeshPool

Object pool for `THREE.InstancedMesh` instances to reduce allocation overhead.

```typescript
class MeshPool {
  acquireMesh(poolId: string, options: MeshPoolOptions): THREE.InstancedMesh
  releaseMesh(poolId: string, mesh: THREE.InstancedMesh): void
  fill(poolId: string, options: MeshPoolOptions, count: number): void
  clearPool(poolId: string): void
  clearAllPools(): void
}
```

### InstanceManager

Manages instance slots within a single `THREE.InstancedMesh`, providing acquire/release semantics for GPU-instanced rendering.

```typescript
class InstanceManager {
  constructor(
    scene: Scene,
    geometry: THREE.BufferGeometry,
    material: THREE.Material,
    options: InstanceManagerOptions
  )

  acquireInstanceSlot(): number
  releaseInstanceSlot(instanceIndex: number): void
  getInstanceCount(): number
  getMaxInstances(): number
  get hasFreeIndices(): boolean
  get mesh(): THREE.InstancedMesh
  dispose(): void
}
```

### SpriteResource

Represents a loaded sprite sheet resource with its texture, sheet properties, and associated mesh pool.

```typescript
class SpriteResource {
  constructor(
    texture: THREE.DataTexture,
    sheetProperties: SheetProperties,
    scene: Scene
  )

  get texture(): THREE.DataTexture
  get sheetProperties(): SheetProperties
  get meshPool(): MeshPool
  get uvTileSize(): THREE.Vector2

  createInstanceManager(
    geometry: THREE.BufferGeometry,
    material: THREE.Material,
    options: InstanceManagerOptions
  ): InstanceManager

  dispose(): void
}
```

### SpriteResourceManager

Top-level manager that caches loaded textures and creates `SpriteResource` objects on demand.

```typescript
class SpriteResourceManager {
  constructor(scene: Scene)

  // Get an existing resource or create one from a texture + sheet properties
  getOrCreateResource(
    texture: THREE.DataTexture,
    sheetProps: SheetProperties
  ): Promise<SpriteResource>

  // Create a resource from a file path configuration
  createResource(config: ResourceConfig): Promise<SpriteResource>

  clearCache(): void
}
```

### Example

```typescript
import { SpriteResourceManager } from "@opentui/core/3d"

const resourceManager = new SpriteResourceManager(scene)

// Load a sprite sheet resource
const resource = await resourceManager.createResource({
  imagePath: "./assets/characters.png",
  sheetNumFrames: 16,
})

// Create an instance manager for batched rendering
const instances = resource.createInstanceManager(
  new THREE.PlaneGeometry(1, 1),
  material,
  { maxInstances: 100, renderOrder: 1 }
)

const slotIndex = instances.acquireInstanceSlot()
// ... set instance transform via instances.mesh.setMatrixAt(slotIndex, matrix)
instances.releaseInstanceSlot(slotIndex)
```

---

## SuperSampling

The 3D system supports two super-sampling strategies to improve rendering quality in the terminal where each cell represents a block of pixels.

### SuperSampleType

Controls where super-sampling computation runs:

| Value | Description |
|-------|-------------|
| `SuperSampleType.NONE` | No super-sampling. Direct 1:1 pixel mapping. |
| `SuperSampleType.GPU` | GPU compute shader downsamples the framebuffer. Fastest for large scenes. |
| `SuperSampleType.CPU` | CPU-side downsampling. Fallback when GPU compute is unavailable. |

### SuperSampleAlgorithm

Controls the downsampling algorithm:

| Value | Description |
|-------|-------------|
| `SuperSampleAlgorithm.STANDARD` | Standard area-average downsampling. |
| `SuperSampleAlgorithm.PRE_SQUEEZED` | Optimized for terminal cells which are taller than wide (roughly 2:1 aspect). |

### Usage

```typescript
const threeRenderer = new ThreeCliRenderer(cliRenderer, {
  width: 160,
  height: 80,
  superSample: SuperSampleType.GPU,
})

threeRenderer.setSuperSampleAlgorithm(SuperSampleAlgorithm.PRE_SQUEEZED)
threeRenderer.toggleSuperSampling() // Cycle through modes
```

---

## Architecture

### Rendering Pipeline

The 3D rendering pipeline converts a Three.js scene graph into terminal characters:

```
Three.js Scene
    |
    v
ThreeRenderable.renderSelf()
    |
    v
ThreeCliRenderer.drawScene()
    |  - Renders scene with Three.js WebGPURenderer
    |  - Writes to CLICanvas GPU texture
    v
CLICanvas.readPixelsIntoBuffer()
    |  - Optional: GPU/CPU super-sampling pass
    |  - Maps GPU buffer to CPU memory
    |  - Writes RGBA pixels into OptimizedBuffer
    v
OptimizedBuffer
    |  - Buffer is composited into the terminal render tree
    |  - ANSI escape sequences generated for colored output
    v
Terminal Output
```

### Key Design Decisions

1. **WebGPU via `bun-webgpu`**: The system uses Bun's native WebGPU bindings rather than a software rasterizer, providing hardware-accelerated rendering even in a terminal context.

2. **`CLICanvas` as a DOM shim**: Three.js expects a browser `<canvas>` element. `CLICanvas` implements the subset of the canvas API that Three.js needs (`getContext`, `setSize`, event listener stubs) while routing all rendering through WebGPU.

3. **GPU-instanced sprites**: The sprite system uses `THREE.InstancedMesh` with custom buffer attributes for UV offsets and frame data. This allows thousands of animated sprites with a single draw call.

4. **Compute shader super-sampling**: The `PRE_SQUEEZED` algorithm accounts for terminal cell aspect ratios (typically ~2:1 height:width) during the downsample pass, producing more visually accurate output.

5. **Resource pooling**: `MeshPool` and `InstanceManager` provide object pooling to avoid GPU resource allocation during runtime, which is critical for smooth animation at terminal frame rates.

---

## Related Documentation

- [Animation System](./animation.md) -- Timeline, SpriteAnimator, particle generators, and explosion effects
- [Physics System](./physics.md) -- Physics interface, Rapier adapter, Planck adapter, and physics-driven effects
- [Core API](./core-api.md) -- Renderable base class, OptimizedBuffer, CliRenderer
